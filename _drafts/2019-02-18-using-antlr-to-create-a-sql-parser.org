#+OPTIONS: ':nil *:t -:t ::t <:t H:5 \n:nil ^:{} arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+TITLE: 使用 antlr4 生成 SQL 解析器
#+DATE: <2019-02-18 Mon>
#+AUTHOR: Ynjxsjmh
#+EMAIL: ynjxsjmh@gmail.com
#+FILETAGS: :antlr:

* ANTLR 介绍
Antlr4 是 ANother Tool for Language Recognition 的第四个版本。它是一款强大的解析器生成工具，可用来读取、处理、执行和翻译结构化文本或二进制文件。

Antlr4 生成的解析器包含了词法分析程序和语法分析程序，这就是编译原理课程中的词法分析和语法分析。我们只需要知道词法分析程序是将输入的代码字符序列转换成标记 (Token) 序列的程序，而语法分析程序则是将标记序列转换成语法树的程序。好在按照 Antlr4 规范制定了语法定义，Antlr4 就可以为我们生成解析器源码，它不仅可以生成 Java 源码，还可以生成 JavaScript 和 TypeScript 源码。

* 案例
- Hive 和 Spark 使用 antlr 生成词法语法解析器；
- Twitter 使用 antlr 来解析用户输入的查询内容；
- Oracle 把 antlr 的功能内嵌在 SQL 开发 IDE 中；
- NetBeans IDE 使用 antlr 解析 C++ 语言；
- 也有公司使用 antlr 来从文件中抽取信息。

* Windows 上 ANTLR v4 的安装使用
此部分参照 Github 上的 [[https://github.com/antlr/antlr4/blob/master/doc/getting-started.md][Getting Started with ANTLR v4]]，简单来说，使用 ANTLR v4，一般分为三步：

1. 按照 ANTLR v4 定义的语法编写待解析语言的语法定义文件，绝大部分语言的 ANTLR v4 语法定义可以在仓库 [[https://github.com/antlr/grammars-v4/][antlr/grammars-v4]] 中找到，一般以 g4 为语法定义文件的后缀
2. 运行 ANTLR 工具，生成指定目标语言的解析器源代码
3. 使用生成的解析器完成代码的解析等 


下面我来介绍一下生成 C++ MySQL 解析器的步骤：

1. 首先你得有 Java 1.6 以上的版本（保证你能在命令行中使用 =java= 命令）
2. 从上面那个语法仓库中下载 mysql 整个文件夹
3. 从 https://www.antlr.org/download/ 下载最新版本的 antlr-version-complete.jar

然后将 antlr-complete.jar 路径加入 CLASSPATH，此时有两种选择：
- 永久加入
- 临时加入：命令行中使用命令 ~SET CLASSPATH=.;your\path\to\antlr-version-complete.jar;%CLASSPATH%~

*注意* 临时加入的话只在当前打开的命令行窗口中有效，打开其他的命令行窗口时 CLASSPATH 中就没有该路径了。

加入 CLASSPATH 的目的是为了方便，如果你选择不加入，后面提到的 antlr-version-complete.jar 就必须以相对或绝对路径代替。

接下来使用 java 命令对 mysql 文件夹中的两个语法文件 MySqlLexer.g4 和 MySqlParser.g4 进行解析[fn:1]，来生成 C++ 解析器的源代码。命令如下：

#+BEGIN_SRC bash
java org.antlr.v4.Tool -Dlanguage=Cpp -o ../src MySqlLexer.g4 MySqlParser.g4
#+END_SRC

*注意* 运行上述命令前必须先 cd 到那两个语法文件路径下。

在命令行中运行 =java org.antlr.v4.Tool= 可以查阅其使用规则[fn:2]

综合上面两步，我们可以写出以下 bat 文件,并将该 bat 文件放置到和两个语法文件一样的文件夹下来一次完成：

#+BEGIN_SRC bash
SET CLASSPATH=.;your/path/to/antlr-4.7.2-complete.jar;%CLASSPATH%

java org.antlr.v4.Tool -Dlanguage=Cpp -o ../src MySQLLexer.g4 MySQLParser.g4
#+END_SRC


做完上面的工作，我们就可以在 -o 指定的 ../src 文件夹下找到生成的 cpp 文件
#+BEGIN_SRC bash
E:\program\parser\src> ls -l
total 6002
-rwxrwx---+ 1 Administrators None  664752 Feb 19 13:44 MySQLLexer.cpp
-rwxrwx---+ 1 Administrators None   19122 Feb 19 13:44 MySQLLexer.h
-rwxrwx---+ 1 Administrators None  401282 Feb 19 13:44 MySQLLexer.interp
-rwxrwx---+ 1 Administrators None   29480 Feb 19 13:44 MySQLLexer.tokens
-rwxrwx---+ 1 Administrators None 4064177 Feb 19 13:44 MySQLParser.cpp
-rwxrwx---+ 1 Administrators None  450507 Feb 19 13:44 MySQLParser.h
-rwxrwx---+ 1 Administrators None  263549 Feb 19 13:44 MySQLParser.interp
-rwxrwx---+ 1 Administrators None   29480 Feb 19 13:44 MySQLParser.tokens
-rwxrwx---+ 1 Administrators None     124 Feb 19 13:44 MySQLParserBaseListener.c
pp
-rwxrwx---+ 1 Administrators None  106791 Feb 19 13:44 MySQLParserBaseListener.h

-rwxrwx---+ 1 Administrators None     120 Feb 19 13:44 MySQLParserListener.cpp
-rwxrwx---+ 1 Administrators None   92669 Feb 19 13:44 MySQLParserListener.h
#+END_SRC


[fn:1] ANTLR v4 的语法规则分为词法 (Lexer) 规则和语法 (Parser) 规则。词法规则定义了怎么将代码字符串序列转换成标记序列；语法规则定义怎么将标记序列转换成语法树。


[fn:2]
#+BEGIN_SRC bash
java org.antlr.v4.Tool 的效果同下
E:\program\parser\grammers> java -jar your/path/to/antlr-4.7.2-complete.jar
ANTLR Parser Generator  Version 4.7.2
 -o ___              specify output directory where all output is generated
 -lib ___            specify location of grammars, tokens files
 -atn                generate rule augmented transition network diagrams
 -encoding ___       specify grammar file encoding; e.g., euc-jp
 -message-format ___ specify output style for messages in antlr, gnu, vs2005
 -long-messages      show exception details when available for errors and warnin
gs
 -listener           generate parse tree listener (default)
 -no-listener        don't generate parse tree listener
 -visitor            generate parse tree visitor
 -no-visitor         don't generate parse tree visitor (default)
 -package ___        specify a package/namespace for the generated code
 -depend             generate file dependencies
 -D<option>=value    set/override a grammar-level option
 -Werror             treat warnings as errors
 -XdbgST             launch StringTemplate visualizer on generated code
 -XdbgSTWait         wait for STViz to close before continuing
 -Xforce-atn         use the ATN simulator for all predictions
 -Xlog               dump lots of logging info to antlr-timestamp.log
 -Xexact-output-dir  all output goes into -o dir regardless of paths/package

E:\program\parser\grammers> java org.antlr.v4.gui.TestRig
java org.antlr.v4.gui.TestRig GrammarName startRuleName
  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]
  [-trace] [-diagnostics] [-SLL]
  [input-filename(s)]
Use startRuleName='tokens' if GrammarName is a lexer grammar.
Omitting input-filename makes rig read from stdin.
#+END_SRC

* 参考
下面那个 repo 感觉是按照 http://blorente.me//Antlr-,-C++-and-CMake-Wait-what.html 这篇文章来的
https://github.com/zag2017/MySQLParser/

[[http://ju.outofmemory.cn/entry/223590][使用 ANTLR 做一个简单的 Python SQL 语法解析器]]




用antlr生成AST，然后用visitor模式遍历AST生成sql，visitor的接口也是为了便于实现ORM映射而设计的

树的遍历了，Antlr 提供了两种遍历手段，一种是 Listener 模式，一种是 Visitor 模式。两者各有优劣，Listener 模式适合全局查找，默认是深度优先遍历，而 Visitor 模式适合指定某个节点作遍历。这种遍历方式默认是先根，然后遍历左右子树。
https://stackoverflow.com/questions/20714492/antlr4-listeners-and-visitors-which-to-implement?rq=1


~java org.antlr.v4.Tool -Dlanguage=Cpp~ 中 =-Dlanguage= 的值我觉得和 =antlr4-4.7.2\runtime\= 下的文件名一样：
https://raw.githubusercontent.com/Ynjxsjmh/ynjxsjmh.github.io/master/img/2019/2019-02-19-01-01.png
* C++ target 参考资料
C++ 使用要先 build 一下 runtime
参考资料如下：
关键字：Parsing with ANTLR 4 and C++

https://github.com/antlr/antlr4/blob/master/doc/cpp-target.md
https://github.com/antlr/antlr4/blob/master/runtime/Cpp/README.md
https://stackoverflow.com/questions/54621811/undefined-reference-problem-with-antlr4-c-target